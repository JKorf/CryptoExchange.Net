<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CryptoExchange.Net</name>
    </assembly>
    <members>
        <member name="T:CryptoExchange.Net.Attributes.JsonConversionAttribute">
            <summary>
            Used for conversion in ArrayConverter
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Attributes.JsonOptionalPropertyAttribute">
            <summary>
            Marks property as optional
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Authentication.ApiCredentials">
            <summary>
            Api credentials info
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Authentication.ApiCredentials.Key">
            <summary>
            The api key to authenticate requests
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Authentication.ApiCredentials.Secret">
            <summary>
            The api secret to authenticate requests
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Authentication.ApiCredentials.PrivateKey">
            <summary>
            The private key to authenticate requests
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.ApiCredentials.#ctor(CryptoExchange.Net.Authentication.PrivateKey)">
            <summary>
            Create Api credentials providing a private key for authentication
            </summary>
            <param name="privateKey">The private key used for signing</param>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.ApiCredentials.#ctor(System.Security.SecureString,System.Security.SecureString)">
            <summary>
            Create Api credentials providing a api key and secret for authentication
            </summary>
            <param name="key">The api key used for identification</param>
            <param name="secret">The api secret used for signing</param>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.ApiCredentials.#ctor(System.String,System.String)">
            <summary>
            Create Api credentials providing a api key and secret for authentication
            </summary>
            <param name="key">The api key used for identification</param>
            <param name="secret">The api secret used for signing</param>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.ApiCredentials.Copy">
            <summary>
            Copy the credentials
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.ApiCredentials.#ctor(System.IO.Stream,System.String,System.String)">
            <summary>
            Create Api credentials providing a stream containing json data. The json data should include two values: apiKey and apiSecret
            </summary>
            <param name="inputStream">The stream containing the json data</param>
            <param name="identifierKey">A key to identify the credentials for the API. For example, when set to `binanceKey` the json data should contain a value for the property `binanceKey`. Defaults to 'apiKey'.</param>
            <param name="identifierSecret">A key to identify the credentials for the API. For example, when set to `binanceSecret` the json data should contain a value for the property `binanceSecret`. Defaults to 'apiSecret'.</param>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.ApiCredentials.TryGetValue(Newtonsoft.Json.Linq.JToken,System.String)">
            <summary>
            Try get the value of a key from a JToken
            </summary>
            <param name="data"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.ApiCredentials.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Authentication.AuthenticationProvider">
            <summary>
            Base class for authentication providers
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Authentication.AuthenticationProvider.Credentials">
            <summary>
            The provided credentials
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.#ctor(CryptoExchange.Net.Authentication.ApiCredentials)">
            <summary>
            ctor
            </summary>
            <param name="credentials"></param>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.AddAuthenticationToParameters(System.String,System.Net.Http.HttpMethod,System.Collections.Generic.Dictionary{System.String,System.Object},System.Boolean)">
            <summary>
            Add authentication to the parameter list
            </summary>
            <param name="uri"></param>
            <param name="method"></param>
            <param name="parameters"></param>
            <param name="signed"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.AddAuthenticationToHeaders(System.String,System.Net.Http.HttpMethod,System.Collections.Generic.Dictionary{System.String,System.Object},System.Boolean)">
            <summary>
            Add authentication to the header dictionary
            </summary>
            <param name="uri"></param>
            <param name="method"></param>
            <param name="parameters"></param>
            <param name="signed"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.Sign(System.String)">
            <summary>
            Sign a string
            </summary>
            <param name="toSign"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.Sign(System.Byte[])">
            <summary>
            Sign a byte array
            </summary>
            <param name="toSign"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.AuthenticationProvider.ByteToString(System.Byte[])">
            <summary>
            Convert byte array to hex
            </summary>
            <param name="buff"></param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Authentication.PrivateKey">
            <summary>
            Private key info
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Authentication.PrivateKey.Key">
            <summary>
            The private key
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Authentication.PrivateKey.Passphrase">
            <summary>
            The private key's pass phrase
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Authentication.PrivateKey.IsEncrypted">
            <summary>
            Indicates if the private key is encrypted or not
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.PrivateKey.#ctor(System.Security.SecureString,System.Security.SecureString)">
            <summary>
            Create a private key providing an encrypted key information
            </summary>
            <param name="key">The private key used for signing</param>
            <param name="passphrase">The private key's passphrase</param>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.PrivateKey.#ctor(System.String,System.String)">
            <summary>
            Create a private key providing an encrypted key information
            </summary>
            <param name="key">The private key used for signing</param>
            <param name="passphrase">The private key's passphrase</param>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.PrivateKey.#ctor(System.Security.SecureString)">
            <summary>
            Create a private key providing an unencrypted key information
            </summary>
            <param name="key">The private key used for signing</param>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.PrivateKey.#ctor(System.String)">
            <summary>
            Create a private key providing an encrypted key information
            </summary>
            <param name="key">The private key used for signing</param>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.PrivateKey.Copy">
            <summary>
            Copy the private key
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Authentication.PrivateKey.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.BaseClient">
            <summary>
            The base for all clients
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.BaseClient.BaseAddress">
            <summary>
            The address of the client
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.BaseClient.log">
            <summary>
            The log object
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.BaseClient.apiProxy">
            <summary>
            The api proxy
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.BaseClient.authProvider">
            <summary>
            The auth provider
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.BaseClient.lastId">
            <summary>
            The last used id
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.BaseClient.idLock">
            <summary>
            Lock for id generating
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.BaseClient.LastId">
            <summary>
            Last is used
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.BaseClient.#ctor(CryptoExchange.Net.Objects.ClientOptions,CryptoExchange.Net.Authentication.AuthenticationProvider)">
            <summary>
            ctor
            </summary>
            <param name="options"></param>
            <param name="authenticationProvider"></param>
        </member>
        <member name="M:CryptoExchange.Net.BaseClient.SetAuthenticationProvider(CryptoExchange.Net.Authentication.AuthenticationProvider)">
            <summary>
            Set the authentication provider
            </summary>
            <param name="authenticationProvider"></param>
        </member>
        <member name="M:CryptoExchange.Net.BaseClient.ValidateJson(System.String)">
            <summary>
            Tries to parse the json data and returns a token
            </summary>
            <param name="data">The data to parse</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.BaseClient.Deserialize``1(System.String,System.Boolean,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Deserialize a string into an object
            </summary>
            <typeparam name="T">The type to deserialize into</typeparam>
            <param name="data">The data to deserialize</param>
            <param name="checkObject">Whether or not the parsing should be checked for missing properties (will output data to the logging if log verbosity is Debug)</param>
            <param name="serializer">A specific serializer to use</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.BaseClient.Deserialize``1(Newtonsoft.Json.Linq.JToken,System.Boolean,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Deserialize a JToken into an object
            </summary>
            <typeparam name="T">The type to deserialize into</typeparam>
            <param name="obj">The data to deserialize</param>
            <param name="checkObject">Whether or not the parsing should be checked for missing properties (will output data to the logging if log verbosity is Debug)</param>
            <param name="serializer">A specific serializer to use</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.BaseClient.Deserialize``1(System.IO.Stream,Newtonsoft.Json.JsonSerializer)">
            <summary>
            Deserialize a stream into an object
            </summary>
            <typeparam name="T">The type to deserialize into</typeparam>
            <param name="stream">The stream to deserialize</param>
            <param name="serializer">A specific serializer to use</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.BaseClient.NextId">
            <summary>
            Generate a unique id
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.BaseClient.FillPathParameter(System.String,System.String[])">
            <summary>
            Fill parameters in a path. Parameters are specified by '{}' and should be specified in occuring sequence
            </summary>
            <param name="path">The total path string</param>
            <param name="values">The values to fill</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.BaseClient.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Converters.ArrayConverter">
            <summary>
            Converter for arrays to properties
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.ArrayConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.ArrayConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.ArrayConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Converters.ArrayPropertyAttribute">
            <summary>
            Mark property as an index in the array
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Converters.ArrayPropertyAttribute.Index">
            <summary>
            The index in the array
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.ArrayPropertyAttribute.#ctor(System.Int32)">
            <summary>
            ctor
            </summary>
            <param name="index"></param>
        </member>
        <member name="T:CryptoExchange.Net.Converters.BaseConverter`1">
            <summary>
            Base class for enum converters
            </summary>
            <typeparam name="T">Type of enum to convert</typeparam>
        </member>
        <member name="P:CryptoExchange.Net.Converters.BaseConverter`1.Mapping">
            <summary>
            The enum->string mapping
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.BaseConverter`1.#ctor(System.Boolean)">
            <summary>
            ctor
            </summary>
            <param name="useQuotes"></param>
        </member>
        <member name="M:CryptoExchange.Net.Converters.BaseConverter`1.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.BaseConverter`1.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.BaseConverter`1.ReadString(System.String)">
            <summary>
            Convert a string value
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Converters.BaseConverter`1.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Converters.TimestampConverter">
            <summary>
            converter for milliseconds to datetime
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.TimestampConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.TimestampConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.TimestampConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Converters.TimestampNanoSecondsConverter">
            <summary>
            Converter for nanoseconds to datetime
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.TimestampNanoSecondsConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.TimestampNanoSecondsConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.TimestampNanoSecondsConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Converters.TimestampSecondsConverter">
            <summary>
            Converter for seconds to datetime
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.TimestampSecondsConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.TimestampSecondsConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.TimestampSecondsConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Converters.UTCDateTimeConverter">
            <summary>
            Converter for utc datetime
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Converters.UTCDateTimeConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.UTCDateTimeConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Converters.UTCDateTimeConverter.CanConvert(System.Type)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.ExtensionMethods">
            <summary>
            Helper methods
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.AddParameter(System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.String)">
            <summary>
            Add a parameter
            </summary>
            <param name="parameters"></param>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.AddParameter(System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.Object)">
            <summary>
            Add a parameter
            </summary>
            <param name="parameters"></param>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.AddOptionalParameter(System.Collections.Generic.Dictionary{System.String,System.Object},System.String,System.Object)">
            <summary>
            Add an optional parameter. Not added if value is null
            </summary>
            <param name="parameters"></param>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.AddOptionalParameter(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.String)">
            <summary>
            Add an optional parameter. Not added if value is null
            </summary>
            <param name="parameters"></param>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.CreateParamString(System.Collections.Generic.Dictionary{System.String,System.Object},System.Boolean,CryptoExchange.Net.Objects.ArrayParametersSerialization)">
            <summary>
            Create a query string of the specified parameters
            </summary>
            <param name="parameters">The parameters to use</param>
            <param name="urlEncodeValues">Whether or not the values should be url encoded</param>
            <param name="serializationType">How to serialize array parameters</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.GetString(System.Security.SecureString)">
            <summary>
            Get the string the secure string is representing
            </summary>
            <param name="source">The source secure string</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.ToSecureString(System.String)">
            <summary>
            Create a secure string from a string
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.WaitOneAsync(System.Threading.WaitHandle,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Wait one async
            </summary>
            <param name="handle"></param>
            <param name="millisecondsTimeout"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.WaitOneAsync(System.Threading.WaitHandle,System.TimeSpan)">
            <summary>
            Wait one async
            </summary>
            <param name="handle"></param>
            <param name="timeout"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.ToJToken(System.String,CryptoExchange.Net.Logging.Log)">
            <summary>
            String to JToken
            </summary>
            <param name="stringData"></param>
            <param name="log"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.ValidateIntValues(System.Int32,System.String,System.Int32[])">
            <summary>
            Validates an int is one of the allowed values
            </summary>
            <param name="value">Value of the int</param>
            <param name="argumentName">Name of the parameter</param>
            <param name="allowedValues">Allowed values</param>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.ValidateIntBetween(System.Int32,System.String,System.Int32,System.Int32)">
            <summary>
            Validates an int is between two values
            </summary>
            <param name="value">The value of the int</param>
            <param name="argumentName">Name of the parameter</param>
            <param name="minValue">Min value</param>
            <param name="maxValue">Max value</param>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.ValidateNotNull(System.String,System.String)">
            <summary>
            Validates a string is not null or empty
            </summary>
            <param name="value">The value of the string</param>
            <param name="argumentName">Name of the parameter</param>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.ValidateNotNull(System.Object,System.String)">
            <summary>
            Validates an object is not null
            </summary>
            <param name="value">The value of the object</param>
            <param name="argumentName">Name of the parameter</param>
        </member>
        <member name="M:CryptoExchange.Net.ExtensionMethods.ValidateNotNull``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Validates a list is not null or empty
            </summary>
            <param name="value">The value of the object</param>
            <param name="argumentName">Name of the parameter</param>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.IRateLimiter">
            <summary>
            Rate limiter interface
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IRateLimiter.LimitRequest(CryptoExchange.Net.RestClient,System.String,CryptoExchange.Net.Objects.RateLimitingBehaviour)">
            <summary>
            Limit the request if needed
            </summary>
            <param name="client"></param>
            <param name="url"></param>
            <param name="limitBehaviour"></param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.IRequest">
            <summary>
            Request interface
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IRequest.Accept">
            <summary>
            Accept header
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IRequest.Content">
            <summary>
            Content
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IRequest.Method">
            <summary>
            Method
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IRequest.Uri">
            <summary>
            Uri
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IRequest.SetContent(System.Byte[])">
            <summary>
            Set byte content
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IRequest.SetContent(System.String,System.String)">
            <summary>
            Set string content
            </summary>
            <param name="data"></param>
            <param name="contentType"></param>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IRequest.AddHeader(System.String,System.String)">
            <summary>
            Add a header to the request
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IRequest.GetResponse(System.Threading.CancellationToken)">
            <summary>
            Get the response
            </summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.IRequestFactory">
            <summary>
            Request factory interface
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IRequestFactory.Create(System.Net.Http.HttpMethod,System.String)">
            <summary>
            Create a request for an uri
            </summary>
            <param name="method"></param>
            <param name="uri"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IRequestFactory.Configure(System.TimeSpan,CryptoExchange.Net.Objects.ApiProxy)">
            <summary>
            Configure the requests created by this factory
            </summary>
            <param name="requestTimeout">Request timeout to use</param>
            <param name="proxy">Proxy settings to use</param>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.IResponse">
            <summary>
            Response object interface
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IResponse.StatusCode">
            <summary>
            The response status code
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IResponse.IsSuccessStatusCode">
            <summary>
            Whether the status code indicates a success status
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IResponse.ResponseHeaders">
            <summary>
            The response headers
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IResponse.GetResponseStream">
            <summary>
            Get the response stream
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IResponse.Close">
            <summary>
            Close the response
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.IRestClient">
            <summary>
            Base class for rest API implementations
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IRestClient.RequestFactory">
            <summary>
            The factory for creating requests. Used for unit testing
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IRestClient.RateLimitBehaviour">
            <summary>
            What should happen when hitting a rate limit
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IRestClient.RateLimiters">
            <summary>
            List of active rate limiters
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IRestClient.TotalRequestsMade">
            <summary>
            The total amount of requests made
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IRestClient.BaseAddress">
            <summary>
            The base address of the API
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IRestClient.AddRateLimiter(CryptoExchange.Net.Interfaces.IRateLimiter)">
            <summary>
            Adds a rate limiter to the client. There are 2 choices, the <see cref="T:CryptoExchange.Net.RateLimiter.RateLimiterTotal"/> and the <see cref="T:CryptoExchange.Net.RateLimiter.RateLimiterPerEndpoint"/>.
            </summary>
            <param name="limiter">The limiter to add</param>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IRestClient.RemoveRateLimiters">
            <summary>
            Removes all rate limiters from this client
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IRestClient.Ping(System.Threading.CancellationToken)">
            <summary>
            Ping to see if the server is reachable
            </summary>
            <returns>The roundtrip time of the ping request</returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IRestClient.PingAsync(System.Threading.CancellationToken)">
            <summary>
            Ping to see if the server is reachable
            </summary>
            <returns>The roundtrip time of the ping request</returns>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.ISocketClient">
            <summary>
            Base class for socket API implementations
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISocketClient.SocketFactory">
            <summary>
            The factory for creating sockets. Used for unit testing
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISocketClient.ReconnectInterval">
            <summary>
            The time in between reconnect attempts
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISocketClient.AutoReconnect">
            <summary>
            Whether the client should try to auto reconnect when losing connection
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISocketClient.BaseAddress">
            <summary>
            The base address of the API
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISocketClient.ResponseTimeout">
            <inheritdoc cref="P:CryptoExchange.Net.Objects.SocketClientOptions.SocketResponseTimeout"/>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISocketClient.SocketNoDataTimeout">
            <inheritdoc cref="P:CryptoExchange.Net.Objects.SocketClientOptions.SocketNoDataTimeout"/>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISocketClient.MaxSocketConnections">
            <summary>
            The max amount of concurrent socket connections
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISocketClient.SocketCombineTarget">
            <inheritdoc cref="P:CryptoExchange.Net.Objects.SocketClientOptions.SocketSubscriptionsCombineTarget"/>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.ISocketClient.Unsubscribe(CryptoExchange.Net.Sockets.UpdateSubscription)">
            <summary>
            Unsubscribe from a stream
            </summary>
            <param name="subscription">The subscription to unsubscribe</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.ISocketClient.UnsubscribeAll">
            <summary>
            Unsubscribe all subscriptions
            </summary>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.ISymbolOrderBook">
            <summary>
            Interface for order book
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBook.Status">
            <summary>
            The status of the order book. Order book is up to date when the status is `Synced`
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBook.LastSequenceNumber">
            <summary>
            Last update identifier
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBook.Symbol">
            <summary>
            The symbol of the order book
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Interfaces.ISymbolOrderBook.OnStatusChange">
            <summary>
            Event when the state changes
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Interfaces.ISymbolOrderBook.OnOrderBookUpdate">
            <summary>
            Event when order book was updated. Be careful! It can generate a lot of events at high-liquidity markets
            </summary>    
        </member>
        <member name="E:CryptoExchange.Net.Interfaces.ISymbolOrderBook.OnBestOffersChanged">
            <summary>
            Event when the BestBid or BestAsk changes ie a Pricing Tick
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBook.LastOrderBookUpdate">
            <summary>
            Timestamp of the last update
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBook.AskCount">
            <summary>
            The number of asks in the book
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBook.BidCount">
            <summary>
            The number of bids in the book
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBook.Asks">
            <summary>
            The list of asks
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBook.Bids">
            <summary>
            The list of bids
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBook.BestBid">
            <summary>
            The best bid currently in the order book
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBook.BestAsk">
            <summary>
            The best ask currently in the order book
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBook.BestOffers">
            <summary>
            BestBid/BesAsk returned as a pair
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.ISymbolOrderBook.Start">
            <summary>
            Start connecting and synchronizing the order book
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.ISymbolOrderBook.StartAsync">
            <summary>
            Start connecting and synchronizing the order book
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.ISymbolOrderBook.Stop">
            <summary>
            Stop syncing the order book
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.ISymbolOrderBook.StopAsync">
            <summary>
            Stop syncing the order book
            </summary>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.ISymbolOrderBookEntry">
            <summary>
            Interface for order book entries
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBookEntry.Quantity">
            <summary>
            The quantity of the entry
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderBookEntry.Price">
            <summary>
            The price of the entry
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.ISymbolOrderSequencedBookEntry">
            <summary>
            Interface for order book entries
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.ISymbolOrderSequencedBookEntry.Sequence">
            <summary>
            Sequence of the update
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.IWebsocket">
            <summary>
            Interface for websocket interaction
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Interfaces.IWebsocket.OnClose">
            <summary>
            Websocket closed
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Interfaces.IWebsocket.OnMessage">
            <summary>
            Websocket message received
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Interfaces.IWebsocket.OnError">
            <summary>
            Websocket error
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Interfaces.IWebsocket.OnOpen">
            <summary>
            Websocket opened
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IWebsocket.Id">
            <summary>
            Id
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IWebsocket.Origin">
            <summary>
            Origin
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IWebsocket.Reconnecting">
            <summary>
            Reconnecting
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IWebsocket.DataInterpreterBytes">
            <summary>
            Handler for byte data
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IWebsocket.DataInterpreterString">
            <summary>
            Handler for string data
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IWebsocket.Url">
            <summary>
            Socket url
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IWebsocket.SocketState">
            <summary>
            State
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IWebsocket.IsClosed">
            <summary>
            Is closed
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IWebsocket.IsOpen">
            <summary>
            Is open
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IWebsocket.SSLProtocols">
            <summary>
            Supported ssl protocols
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Interfaces.IWebsocket.Timeout">
            <summary>
            Timeout
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IWebsocket.Connect">
            <summary>
            Connect the socket
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IWebsocket.Send(System.String)">
            <summary>
            Send data
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IWebsocket.Reset">
            <summary>
            Reset socket
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IWebsocket.Close">
            <summary>
            Close the connecting
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IWebsocket.SetProxy(System.String,System.Int32)">
            <summary>
            Set proxy
            </summary>
            <param name="host"></param>
            <param name="port"></param>
        </member>
        <member name="T:CryptoExchange.Net.Interfaces.IWebsocketFactory">
            <summary>
            Websocket factory interface
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IWebsocketFactory.CreateWebsocket(CryptoExchange.Net.Logging.Log,System.String)">
            <summary>
            Create a websocket for an url
            </summary>
            <param name="log"></param>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Interfaces.IWebsocketFactory.CreateWebsocket(CryptoExchange.Net.Logging.Log,System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Create a websocket for an url
            </summary>
            <param name="log"></param>
            <param name="url"></param>
            <param name="cookies"></param>
            <param name="headers"></param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Logging.DebugTextWriter">
            <summary>
            Default log writer, writes to debug
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Logging.DebugTextWriter.Encoding">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Logging.DebugTextWriter.WriteLine(System.String)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Logging.Log">
            <summary>
            Log implementation
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Logging.Log.Level">
            <summary>
            The verbosity of the logging
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Logging.Log.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Logging.Log.UpdateWriters(System.Collections.Generic.List{System.IO.TextWriter})">
            <summary>
            Set the writers
            </summary>
            <param name="textWriters"></param>
        </member>
        <member name="M:CryptoExchange.Net.Logging.Log.Write(CryptoExchange.Net.Logging.LogVerbosity,System.String)">
            <summary>
            Write a log entry
            </summary>
            <param name="logType"></param>
            <param name="message"></param>
        </member>
        <member name="T:CryptoExchange.Net.Logging.LogVerbosity">
            <summary>
            The log verbosity
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Logging.LogVerbosity.Debug">
            <summary>
            Debug logging
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Logging.LogVerbosity.Info">
            <summary>
            Info logging
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Logging.LogVerbosity.Warning">
            <summary>
            Warning logging
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Logging.LogVerbosity.Error">
            <summary>
            Error logging
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Logging.LogVerbosity.None">
            <summary>
            None, used for disabling logging
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Logging.ThreadSafeFileWriter">
            <summary>
            File writer
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Logging.ThreadSafeFileWriter.Encoding">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Logging.ThreadSafeFileWriter.#ctor(System.String)">
            <summary>
            ctor
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:CryptoExchange.Net.Logging.ThreadSafeFileWriter.WriteLine(System.String)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Logging.ThreadSafeFileWriter.Dispose(System.Boolean)">
            <summary>
            Dispose
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:CryptoExchange.Net.Objects.ApiProxy">
            <summary>
            Proxy info
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.ApiProxy.Host">
            <summary>
            The host address of the proxy
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.ApiProxy.Port">
            <summary>
            The port of the proxy
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.ApiProxy.Login">
            <summary>
            The login of the proxy
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.ApiProxy.Password">
            <summary>
            The password of the proxy
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ApiProxy.#ctor(System.String,System.Int32)">
            <summary>
            Create new settings for a proxy
            </summary>
            <param name="host">The proxy hostname/ip</param>
            <param name="port">The proxy port</param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ApiProxy.#ctor(System.String,System.Int32,System.String,System.String)">
            <summary>
            Create new settings for a proxy
            </summary>
            <param name="host">The proxy hostname/ip</param>
            <param name="port">The proxy port</param>
            <param name="login">The proxy login</param>
            <param name="password">The proxy password</param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ApiProxy.#ctor(System.String,System.Int32,System.String,System.Security.SecureString)">
            <summary>
            Create new settings for a proxy
            </summary>
            <param name="host">The proxy hostname/ip</param>
            <param name="port">The proxy port</param>
            <param name="login">The proxy login</param>
            <param name="password">The proxy password</param>
        </member>
        <member name="T:CryptoExchange.Net.Objects.ByteOrderComparer">
            <summary>
            Comparer for byte order
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ByteOrderComparer.Compare(System.Byte[],System.Byte[])">
            <summary>
            Compare function
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Objects.CallResult`1">
            <summary>
            The result of an operation
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:CryptoExchange.Net.Objects.CallResult`1.Data">
            <summary>
            The data returned by the call
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.CallResult`1.Error">
            <summary>
            An error if the call didn't succeed
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.CallResult`1.Success">
            <summary>
            Whether the call was successful
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.CallResult`1.#ctor(`0,CryptoExchange.Net.Objects.Error)">
            <summary>
            ctor
            </summary>
            <param name="data"></param>
            <param name="error"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.CallResult`1.op_Implicit(CryptoExchange.Net.Objects.CallResult{`0})~System.Boolean">
            <summary>
            Overwrite bool check so we can use if(callResult) instead of if(callResult.Success)
            </summary>
            <param name="obj"></param>
        </member>
        <member name="T:CryptoExchange.Net.Objects.WebCallResult`1">
            <summary>
            The result of a request
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:CryptoExchange.Net.Objects.WebCallResult`1.ResponseStatusCode">
            <summary>
            The status code of the response. Note that a OK status does not always indicate success, check the Success parameter for this.
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.WebCallResult`1.ResponseHeaders">
            <summary>
            The response headers
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.WebCallResult`1.#ctor(System.Nullable{System.Net.HttpStatusCode},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Collections.Generic.IEnumerable{System.String}}},`0,CryptoExchange.Net.Objects.Error)">
            <summary>
            ctor
            </summary>
            <param name="code"></param>
            <param name="responseHeaders"></param>
            <param name="data"></param>
            <param name="error"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.WebCallResult`1.CreateErrorResult(CryptoExchange.Net.Objects.Error)">
            <summary>
            Create an error result
            </summary>
            <param name="error"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Objects.WebCallResult`1.CreateErrorResult(System.Nullable{System.Net.HttpStatusCode},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Collections.Generic.IEnumerable{System.String}}},CryptoExchange.Net.Objects.Error)">
            <summary>
            Create an error result
            </summary>
            <param name="code"></param>
            <param name="responseHeaders"></param>
            <param name="error"></param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Objects.Constants">
            <summary>
            Constants
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.Constants.JsonContentHeader">
            <summary>
            Json content type header
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.Constants.FormContentHeader">
            <summary>
            Form content type header
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Objects.RateLimitingBehaviour">
            <summary>
            What to do when a request would exceed the rate limit
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.RateLimitingBehaviour.Fail">
            <summary>
            Fail the request
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.RateLimitingBehaviour.Wait">
            <summary>
            Wait till the request can be send
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Objects.PostParameters">
            <summary>
            Where the post parameters should be added
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.PostParameters.InBody">
            <summary>
            Post parameters in body
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.PostParameters.InUri">
            <summary>
            Post parameters in url
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Objects.RequestBodyFormat">
            <summary>
            The format of the request body
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.RequestBodyFormat.FormData">
            <summary>
            Form data
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.RequestBodyFormat.Json">
            <summary>
            Json
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Objects.OrderBookStatus">
            <summary>
            Status of the order book
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.OrderBookStatus.Disconnected">
            <summary>
            Not connected
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.OrderBookStatus.Connecting">
            <summary>
            Connecting
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.OrderBookStatus.Syncing">
            <summary>
            Syncing data
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.OrderBookStatus.Synced">
            <summary>
            Data synced, order book is up to date
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Objects.OrderBookEntryType">
            <summary>
            Order book entry type
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.OrderBookEntryType.Ask">
            <summary>
            Ask
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.OrderBookEntryType.Bid">
            <summary>
            Bid
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Objects.ArrayParametersSerialization">
            <summary>
            Define how array parameters should be send
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.ArrayParametersSerialization.MultipleValues">
            <summary>
            Send multiple key=value for each entry
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Objects.ArrayParametersSerialization.Array">
            <summary>
            Create an []=value array
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Objects.Error">
            <summary>
            Base class for errors
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Error.Code">
            <summary>
            The error code
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Error.Message">
            <summary>
            The message for the error that occured
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.Error.Data">
            <summary>
            Optional data for the error
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.Error.#ctor(System.Int32,System.String,System.Object)">
            <summary>
            ctor
            </summary>
            <param name="code"></param>
            <param name="message"></param>
            <param name="data"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.Error.ToString">
            <summary>
            String representation
            </summary>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Objects.CantConnectError">
            <summary>
            Cant reach server error
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.CantConnectError.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Objects.NoApiCredentialsError">
            <summary>
            No api credentials provided while trying to access private endpoint
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.NoApiCredentialsError.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Objects.ServerError">
            <summary>
            Error returned by the server
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ServerError.#ctor(System.String,System.Object)">
            <summary>
            ctor
            </summary>
            <param name="message"></param>
            <param name="data"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ServerError.#ctor(System.Int32,System.String,System.Object)">
            <summary>
            ctor
            </summary>
            <param name="code"></param>
            <param name="message"></param>
            <param name="data"></param>
        </member>
        <member name="T:CryptoExchange.Net.Objects.WebError">
            <summary>
            Web error returned by the server
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.WebError.#ctor(System.Object)">
            <summary>
            ctor
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:CryptoExchange.Net.Objects.DeserializeError">
            <summary>
            Error while deserializing data
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.DeserializeError.#ctor(System.Object)">
            <summary>
            ctor
            </summary>
            <param name="data">Deserializing data</param>
        </member>
        <member name="T:CryptoExchange.Net.Objects.UnknownError">
            <summary>
            Unknown error
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.UnknownError.#ctor(System.Object)">
            <summary>
            ctor
            </summary>
            <param name="data">Error data</param>
        </member>
        <member name="T:CryptoExchange.Net.Objects.ArgumentError">
            <summary>
            An invalid parameter has been provided
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ArgumentError.#ctor(System.String)">
            <summary>
            ctor
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:CryptoExchange.Net.Objects.RateLimitError">
            <summary>
            Rate limit exceeded
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.RateLimitError.#ctor(System.String)">
            <summary>
            ctor
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:CryptoExchange.Net.Objects.CancellationRequestedError">
            <summary>
            Cancellation requested
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.CancellationRequestedError.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Objects.BaseOptions">
            <summary>
            Base options
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.BaseOptions.LogVerbosity">
            <summary>
            The log verbosity
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.BaseOptions.LogWriters">
            <summary>
            The log writers
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.BaseOptions.ToString">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Objects.OrderBookOptions">
            <summary>
            Base for order book options
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.OrderBookOptions.OrderBookName">
            <summary>
            The name of the order book implementation
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.OrderBookOptions.SequenceNumbersAreConsecutive">
            <summary>
            Whether each update should have a consecutive id number. Used to identify and reconnect when numbers are skipped.
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.OrderBookOptions.#ctor(System.String,System.Boolean)">
            <summary>
            </summary>
            <param name="name">The name of the order book implementation</param>
            <param name="sequencesAreConsecutive">Whether each update should have a consecutive id number. Used to identify and reconnect when numbers are skipped.</param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.OrderBookOptions.ToString">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Objects.ClientOptions">
            <summary>
            Base client options
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.ClientOptions.BaseAddress">
            <summary>
            The base address of the client
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.ClientOptions.ApiCredentials">
            <summary>
            The api credentials
            </summary>        
        </member>
        <member name="P:CryptoExchange.Net.Objects.ClientOptions.Proxy">
            <summary>
            Proxy to use
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ClientOptions.#ctor(System.String)">
            <summary>
            ctor
            </summary>
            <param name="baseAddress"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.ClientOptions.ToString">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Objects.RestClientOptions">
            <summary>
            Base for rest client options
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.RestClientOptions.RateLimiters">
            <summary>
            List of rate limiters to use
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.RestClientOptions.RateLimitingBehaviour">
            <summary>
            What to do when a call would exceed the rate limit
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.RestClientOptions.RequestTimeout">
            <summary>
            The time the server has to respond to a request before timing out
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.RestClientOptions.#ctor(System.String)">
            <summary>
            ctor
            </summary>
            <param name="baseAddress"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.RestClientOptions.Copy``1">
            <summary>
            Create a copy of the options
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Objects.RestClientOptions.ToString">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Objects.SocketClientOptions">
            <summary>
            Base for socket client options
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.SocketClientOptions.AutoReconnect">
            <summary>
            Whether or not the socket should automatically reconnect when losing connection
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.SocketClientOptions.ReconnectInterval">
            <summary>
            Time to wait between reconnect attempts
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.SocketClientOptions.SocketResponseTimeout">
            <summary>
            The time to wait for a socket response
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.SocketClientOptions.SocketNoDataTimeout">
            <summary>
            The time after which the connection is assumed to be dropped
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Objects.SocketClientOptions.SocketSubscriptionsCombineTarget">
            <summary>
            The amount of subscriptions that should be made on a single socket connection. Not all exchanges support multiple subscriptions on a single socket.
            Setting this to a higher number increases subscription speed, but having more subscriptions on a single connection will also increase the amount of traffic on that single connection.
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Objects.SocketClientOptions.#ctor(System.String)">
            <summary>
            ctor
            </summary>
            <param name="baseAddress"></param>
        </member>
        <member name="M:CryptoExchange.Net.Objects.SocketClientOptions.Copy``1">
            <summary>
            Create a copy of the options
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Objects.SocketClientOptions.ToString">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.OrderBook.ProcessBufferEntry">
            <summary>
            Buffer entry for order book
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.ProcessBufferEntry.Asks">
            <summary>
            List of asks
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.ProcessBufferEntry.Bids">
            <summary>
            List of bids
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.OrderBook.ProcessBufferSingleSequenceEntry">
            <summary>
            Buffer entry with a single update id per update
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.ProcessBufferSingleSequenceEntry.UpdateId">
            <summary>
            First update id
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.ProcessBufferSingleSequenceEntry.Asks">
            <summary>
            List of asks
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.ProcessBufferSingleSequenceEntry.Bids">
            <summary>
            List of bids
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.OrderBook.ProcessBufferRangeSequenceEntry">
            <summary>
            Buffer entry with a first and last update id
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.ProcessBufferRangeSequenceEntry.FirstUpdateId">
            <summary>
            First update id
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.ProcessBufferRangeSequenceEntry.LastUpdateId">
            <summary>
            Last update id
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.ProcessBufferRangeSequenceEntry.Asks">
            <summary>
            List of asks
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.ProcessBufferRangeSequenceEntry.Bids">
            <summary>
            List of bids
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.OrderBook.SymbolOrderBook">
            <summary>
            Base for order book implementations
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.OrderBook.SymbolOrderBook.processBuffer">
            <summary>
            The process buffer, used while syncing
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.OrderBook.SymbolOrderBook.asks">
            <summary>
            The ask list
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.OrderBook.SymbolOrderBook.bids">
            <summary>
            The bid list
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.Id">
            <summary>
            Order book implementation id
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.OrderBook.SymbolOrderBook.log">
            <summary>
            The log
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.OrderBook.SymbolOrderBook.bookSet">
            <summary>
            If order book is set
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.Status">
            <summary>
            The status of the order book. Order book is up to date when the status is `Synced`
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.LastSequenceNumber">
            <summary>
            Last update identifier
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.Symbol">
            <summary>
            The symbol of the order book
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.OrderBook.SymbolOrderBook.OnStatusChange">
            <summary>
            Event when the state changes
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.OrderBook.SymbolOrderBook.OnBestOffersChanged">
            <summary>
            Event when the BestBid or BestAsk changes ie a Pricing Tick
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.OrderBook.SymbolOrderBook.OnOrderBookUpdate">
            <summary>
            Event when order book was updated, containing the changed bids and asks. Be careful! It can generate a lot of events at high-liquidity markets
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.LastOrderBookUpdate">
            <summary>
            Timestamp of the last update
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.AskCount">
            <summary>
            The number of asks in the book
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.BidCount">
            <summary>
            The number of bids in the book
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.Asks">
            <summary>
            The list of asks
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.Bids">
            <summary>
            The list of bids
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.BestBid">
            <summary>
            The best bid currently in the order book
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.BestAsk">
            <summary>
            The best ask currently in the order book
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.OrderBook.SymbolOrderBook.BestOffers">
            <summary>
            BestBid/BesAsk returned as a pair
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.#ctor(System.String,CryptoExchange.Net.Objects.OrderBookOptions)">
            <summary>
            ctor
            </summary>
            <param name="symbol"></param>
            <param name="options"></param>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.Start">
            <summary>
            Start connecting and synchronizing the order book
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.StartAsync">
            <summary>
            Start connecting and synchronizing the order book
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.Stop">
            <summary>
            Stop syncing the order book
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.StopAsync">
            <summary>
            Stop syncing the order book
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.DoStart">
            <summary>
            Start the order book
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.DoReset">
            <summary>
            Reset the order book
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.DoResync">
            <summary>
            Resync the order book
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.SetInitialOrderBook(System.Int64,System.Collections.Generic.IEnumerable{CryptoExchange.Net.Interfaces.ISymbolOrderBookEntry},System.Collections.Generic.IEnumerable{CryptoExchange.Net.Interfaces.ISymbolOrderBookEntry})">
            <summary>
            Set the initial data for the order book
            </summary>
            <param name="orderBookSequenceNumber">The last update sequence number</param>
            <param name="askList">List of asks</param>
            <param name="bidList">List of bids</param>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.UpdateOrderBook(System.Int64,System.Collections.Generic.IEnumerable{CryptoExchange.Net.Interfaces.ISymbolOrderBookEntry},System.Collections.Generic.IEnumerable{CryptoExchange.Net.Interfaces.ISymbolOrderBookEntry})">
            <summary>
            Update the order book using a single id for an update
            </summary>
            <param name="rangeUpdateId"></param>
            <param name="bids"></param>
            <param name="asks"></param>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.UpdateOrderBook(System.Int64,System.Int64,System.Collections.Generic.IEnumerable{CryptoExchange.Net.Interfaces.ISymbolOrderBookEntry},System.Collections.Generic.IEnumerable{CryptoExchange.Net.Interfaces.ISymbolOrderBookEntry})">
            <summary>
            Update the order book using a first/last update id
            </summary>
            <param name="firstUpdateId"></param>
            <param name="lastUpdateId"></param>
            <param name="bids"></param>
            <param name="asks"></param>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.UpdateOrderBook(System.Collections.Generic.IEnumerable{CryptoExchange.Net.Interfaces.ISymbolOrderSequencedBookEntry},System.Collections.Generic.IEnumerable{CryptoExchange.Net.Interfaces.ISymbolOrderSequencedBookEntry})">
            <summary>
            Update the order book using sequenced entries
            </summary>
            <param name="bids">List of bids</param>
            <param name="asks">List of asks</param>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.CheckProcessBuffer">
            <summary>
            Check and empty the process buffer; see what entries to update the book with
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.ProcessUpdate(System.Int64,CryptoExchange.Net.Objects.OrderBookEntryType,CryptoExchange.Net.Interfaces.ISymbolOrderBookEntry)">
            <summary>
            Update order book with an entry
            </summary>
            <param name="sequence">Sequence number of the update</param>
            <param name="type">Type of entry</param>
            <param name="entry">The entry</param>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.WaitForSetOrderBook(System.Int32)">
            <summary>
            Wait until the order book has been set
            </summary>
            <param name="timeout">Max wait time</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.Dispose">
            <summary>
            Dispose the order book
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.ToString">
            <summary>
            String representation of the top 3 entries
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.OrderBook.SymbolOrderBook.ToString(System.Int32)">
            <summary>
            String representation of the top x entries
            </summary>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.RateLimiter.RateLimiterAPIKey">
            <summary>
            Limits the amount of requests per time period to a certain limit, counts the request per API key.
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiter.RateLimiterAPIKey.#ctor(System.Int32,System.TimeSpan)">
            <summary>
            Create a new RateLimiterAPIKey. This rate limiter limits the amount of requests per time period to a certain limit, counts the request per API key.
            </summary>
            <param name="limitPerApiKey">The amount to limit to</param>
            <param name="perTimePeriod">The time period over which the limit counts</param>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiter.RateLimiterAPIKey.LimitRequest(CryptoExchange.Net.RestClient,System.String,CryptoExchange.Net.Objects.RateLimitingBehaviour)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.RateLimiter.RateLimiterPerEndpoint">
            <summary>
            Limits the amount of requests per time period to a certain limit, counts the request per endpoint.
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiter.RateLimiterPerEndpoint.#ctor(System.Int32,System.TimeSpan)">
            <summary>
            Create a new RateLimiterPerEndpoint. This rate limiter limits the amount of requests per time period to a certain limit, counts the request per endpoint.
            </summary>
            <param name="limitPerEndpoint">The amount to limit to</param>
            <param name="perTimePeriod">The time period over which the limit counts</param>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiter.RateLimiterPerEndpoint.LimitRequest(CryptoExchange.Net.RestClient,System.String,CryptoExchange.Net.Objects.RateLimitingBehaviour)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.RateLimiter.RateLimiterTotal">
            <summary>
            Limits the amount of requests per time period to a certain limit, counts the total amount of requests.
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiter.RateLimiterTotal.#ctor(System.Int32,System.TimeSpan)">
            <summary>
            Create a new RateLimiterTotal. This rate limiter limits the amount of requests per time period to a certain limit, counts the total amount of requests.
            </summary>
            <param name="limit">The amount to limit to</param>
            <param name="perTimePeriod">The time period over which the limit counts</param>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiter.RateLimiterTotal.LimitRequest(CryptoExchange.Net.RestClient,System.String,CryptoExchange.Net.Objects.RateLimitingBehaviour)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.RateLimiter.RateLimitObject">
            <summary>
            Rate limiting object
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RateLimiter.RateLimitObject.LockObject">
            <summary>
            Lock
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiter.RateLimitObject.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiter.RateLimitObject.GetWaitTime(System.DateTime,System.Int32,System.TimeSpan)">
            <summary>
            Get time to wait for a specific time
            </summary>
            <param name="time"></param>
            <param name="limit"></param>
            <param name="perTimePeriod"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.RateLimiter.RateLimitObject.Add(System.DateTime)">
            <summary>
            Add an executed request time
            </summary>
            <param name="time"></param>
        </member>
        <member name="T:CryptoExchange.Net.Requests.Request">
            <summary>
            Request object
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Requests.Request.#ctor(System.Net.Http.HttpRequestMessage,System.Net.Http.HttpClient)">
            <summary>
            Create request object for web request
            </summary>
            <param name="request"></param>
            <param name="client"></param>
        </member>
        <member name="P:CryptoExchange.Net.Requests.Request.Content">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Requests.Request.Accept">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Requests.Request.Method">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Requests.Request.Uri">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Requests.Request.SetContent(System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Requests.Request.AddHeader(System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Requests.Request.SetContent(System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Requests.Request.GetResponse(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Requests.RequestFactory">
            <summary>
            WebRequest factory
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Requests.RequestFactory.Configure(System.TimeSpan,CryptoExchange.Net.Objects.ApiProxy)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Requests.RequestFactory.Create(System.Net.Http.HttpMethod,System.String)">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.Requests.Response">
            <summary>
            HttpWebResponse response object
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Requests.Response.StatusCode">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Requests.Response.IsSuccessStatusCode">
            <inheritdoc />
        </member>
        <member name="P:CryptoExchange.Net.Requests.Response.ResponseHeaders">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Requests.Response.#ctor(System.Net.Http.HttpResponseMessage)">
            <summary>
            Create response for a http response message
            </summary>
            <param name="response">The actual response</param>
        </member>
        <member name="M:CryptoExchange.Net.Requests.Response.GetResponseStream">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Requests.Response.Close">
            <inheritdoc />
        </member>
        <member name="T:CryptoExchange.Net.RestClient">
            <summary>
            Base rest client
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RestClient.RequestFactory">
            <summary>
            The factory for creating requests. Used for unit testing
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.RestClient.postParametersPosition">
            <summary>
            Where to place post parameters
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.RestClient.requestBodyFormat">
            <summary>
            Request body content type
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.RestClient.arraySerialization">
            <summary>
            How to serialize array parameters
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RestClient.RequestTimeout">
            <summary>
            Timeout for requests
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RestClient.RateLimitBehaviour">
            <summary>
            Rate limiting behaviour
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RestClient.RateLimiters">
            <summary>
            List of rate limiters
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.RestClient.TotalRequestsMade">
            <summary>
            Total requests made
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RestClient.#ctor(CryptoExchange.Net.Objects.RestClientOptions,CryptoExchange.Net.Authentication.AuthenticationProvider)">
            <summary>
            ctor
            </summary>
            <param name="exchangeOptions"></param>
            <param name="authenticationProvider"></param>
        </member>
        <member name="M:CryptoExchange.Net.RestClient.AddRateLimiter(CryptoExchange.Net.Interfaces.IRateLimiter)">
            <summary>
            Adds a rate limiter to the client. There are 2 choices, the <see cref="T:CryptoExchange.Net.RateLimiter.RateLimiterTotal"/> and the <see cref="T:CryptoExchange.Net.RateLimiter.RateLimiterPerEndpoint"/>.
            </summary>
            <param name="limiter">The limiter to add</param>
        </member>
        <member name="M:CryptoExchange.Net.RestClient.RemoveRateLimiters">
            <summary>
            Removes all rate limiters from this client
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.RestClient.Ping(System.Threading.CancellationToken)">
            <summary>
            Ping to see if the server is reachable
            </summary>
            <returns>The roundtrip time of the ping request</returns>
        </member>
        <member name="M:CryptoExchange.Net.RestClient.PingAsync(System.Threading.CancellationToken)">
            <summary>
            Ping to see if the server is reachable
            </summary>
            <returns>The roundtrip time of the ping request</returns>
        </member>
        <member name="M:CryptoExchange.Net.RestClient.SendRequest``1(System.Uri,System.Net.Http.HttpMethod,System.Threading.CancellationToken,System.Collections.Generic.Dictionary{System.String,System.Object},System.Boolean,System.Boolean)">
            <summary>
            Execute a request
            </summary>
            <typeparam name="T">The expected result type</typeparam>
            <param name="uri">The uri to send the request to</param>
            <param name="method">The method of the request</param>
            <param name="cancellationToken">Cancellation token</param>
            <param name="parameters">The parameters of the request</param>
            <param name="signed">Whether or not the request should be authenticated</param>
            <param name="checkResult">Whether or not the resulting object should be checked for missing properties in the mapping (only outputs if log verbosity is Debug)</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.RestClient.GetResponse``1(CryptoExchange.Net.Interfaces.IRequest,System.Threading.CancellationToken)">
            <summary>
            Executes the request and returns the string result
            </summary>
            <param name="request">The request object to execute</param>
            <param name="cancellationToken">Cancellation token</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.RestClient.ConstructRequest(System.Uri,System.Net.Http.HttpMethod,System.Collections.Generic.Dictionary{System.String,System.Object},System.Boolean)">
            <summary>
            Creates a request object
            </summary>
            <param name="uri">The uri to send the request to</param>
            <param name="method">The method of the request</param>
            <param name="parameters">The parameters of the request</param>
            <param name="signed">Whether or not the request should be authenticated</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.RestClient.WriteParamBody(CryptoExchange.Net.Interfaces.IRequest,System.Collections.Generic.Dictionary{System.String,System.Object},System.String)">
            <summary>
            Writes the parameters of the request to the request object, either in the query string or the request body
            </summary>
            <param name="request"></param>
            <param name="parameters"></param>
            <param name="contentType"></param>
        </member>
        <member name="M:CryptoExchange.Net.RestClient.ParseErrorResponse(Newtonsoft.Json.Linq.JToken)">
            <summary>
            Parse an error response from the server. Only used when server returns a status other than Success(200)
            </summary>
            <param name="error">The string the request returned</param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.SocketClient">
            <summary>
            Base for socket client implementations
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.SocketClient.SocketFactory">
            <summary>
            The factory for creating sockets. Used for unit testing
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.SocketClient.sockets">
            <summary>
            List of socket connections currently connecting/connected
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.SocketClient.semaphoreSlim">
            <summary>
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.SocketClient.ReconnectInterval">
            <inheritdoc cref="P:CryptoExchange.Net.Objects.SocketClientOptions.ReconnectInterval"/>
        </member>
        <member name="P:CryptoExchange.Net.SocketClient.AutoReconnect">
            <inheritdoc cref="P:CryptoExchange.Net.Objects.SocketClientOptions.AutoReconnect"/>
        </member>
        <member name="P:CryptoExchange.Net.SocketClient.ResponseTimeout">
            <inheritdoc cref="P:CryptoExchange.Net.Objects.SocketClientOptions.SocketResponseTimeout"/>
        </member>
        <member name="P:CryptoExchange.Net.SocketClient.SocketNoDataTimeout">
            <inheritdoc cref="P:CryptoExchange.Net.Objects.SocketClientOptions.SocketNoDataTimeout"/>
        </member>
        <member name="P:CryptoExchange.Net.SocketClient.MaxSocketConnections">
            <summary>
            The max amount of concurrent socket connections
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.SocketClient.SocketCombineTarget">
            <inheritdoc cref="P:CryptoExchange.Net.Objects.SocketClientOptions.SocketSubscriptionsCombineTarget"/>
        </member>
        <member name="F:CryptoExchange.Net.SocketClient.dataInterpreterBytes">
            <summary>
            Handler for byte data
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.SocketClient.dataInterpreterString">
            <summary>
            Handler for string data
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.SocketClient.genericHandlers">
            <summary>
            Generic handlers
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.SocketClient.periodicTask">
            <summary>
            Periodic task
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.SocketClient.periodicEvent">
            <summary>
            Periodic task event
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.SocketClient.disposing">
            <summary>
            Is disposing
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.SocketClient.ContinueOnQueryResponse">
            <summary>
            If true; data which is a response to a query will also be distributed to subscriptions
            If false; data which is a response to a query won't get forwarded to subscriptions as well
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.SocketClient.#ctor(CryptoExchange.Net.Objects.SocketClientOptions,CryptoExchange.Net.Authentication.AuthenticationProvider)">
            <summary>
            Create a socket client
            </summary>
            <param name="exchangeOptions">Client options</param>
            <param name="authenticationProvider">Authentication provider</param>
        </member>
        <member name="M:CryptoExchange.Net.SocketClient.SetDataInterpreter(System.Func{System.Byte[],System.String},System.Func{System.String,System.String})">
            <summary>
            Set a function to interpret the data, used when the data is received as bytes instead of a string
            </summary>
            <param name="byteHandler">Handler for byte data</param>
            <param name="stringHandler">Handler for string data</param>
        </member>
        <member name="M:CryptoExchange.Net.SocketClient.Subscribe``1(System.Object,System.String,System.Boolean,System.Action{``0})">
            <summary>
            Subscribe
            </summary>
            <typeparam name="T">The expected return data</typeparam>
            <param name="request">The request to send</param>
            <param name="identifier">The identifier to use</param>
            <param name="authenticated">If the subscription should be authenticated</param>
            <param name="dataHandler">The handler of update data</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.SocketClient.Subscribe``1(System.String,System.Object,System.String,System.Boolean,System.Action{``0})">
            <summary>
            Subscribe using a specif URL
            </summary>
            <typeparam name="T">The type of the expected data</typeparam>
            <param name="url">The URL to connect to</param>
            <param name="request">The request to send</param>
            <param name="identifier">The identifier to use</param>
            <param name="authenticated">If the subscription should be authenticated</param>
            <param name="dataHandler">The handler of update data</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.SocketClient.SubscribeAndWait(CryptoExchange.Net.Sockets.SocketConnection,System.Object,CryptoExchange.Net.Sockets.SocketSubscription)">
            <summary>
            Sends the subscribe request and waits for a response to that request
            </summary>
            <param name="socket">The connection to send the request on</param>
            <param name="request">The request to send</param>
            <param name="subscription">The subscription the request is for</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.SocketClient.Query``1(System.Object,System.Boolean)">
            <summary>
            Query for data
            </summary>
            <typeparam name="T">Expected result type</typeparam>
            <param name="request">The request to send</param>
            <param name="authenticated">Whether the socket should be authenticated</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.SocketClient.Query``1(System.String,System.Object,System.Boolean)">
            <summary>
            Query for data
            </summary>
            <typeparam name="T">The expected result type</typeparam>
            <param name="url">The url for the request</param>
            <param name="request">The request to send</param>
            <param name="authenticated">Whether the socket should be authenticated</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.SocketClient.QueryAndWait``1(CryptoExchange.Net.Sockets.SocketConnection,System.Object)">
            <summary>
            Sends the query request and waits for the result
            </summary>
            <typeparam name="T">The expected result type</typeparam>
            <param name="socket">The connection to send and wait on</param>
            <param name="request">The request to send</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.SocketClient.ConnectIfNeeded(CryptoExchange.Net.Sockets.SocketConnection,System.Boolean)">
            <summary>
            Checks if a socket needs to be connected and does so if needed
            </summary>
            <param name="socket">The connection to check</param>
            <param name="authenticated">Whether the socket should authenticated</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.SocketClient.HandleQueryResponse``1(CryptoExchange.Net.Sockets.SocketConnection,System.Object,Newtonsoft.Json.Linq.JToken,CryptoExchange.Net.Objects.CallResult{``0}@)">
            <summary>
            Needs to check if a received message was an answer to a query request (preferable by id) and set the callResult out to whatever the response is
            </summary>
            <typeparam name="T">The type of response</typeparam>
            <param name="s">The socket connection</param>
            <param name="request">The request that a response is awaited for</param>
            <param name="data">The message</param>
            <param name="callResult">The interpretation (null if message wasn't a response to the request)</param>
            <returns>True if the message was a response to the query</returns>
        </member>
        <member name="M:CryptoExchange.Net.SocketClient.HandleSubscriptionResponse(CryptoExchange.Net.Sockets.SocketConnection,CryptoExchange.Net.Sockets.SocketSubscription,System.Object,Newtonsoft.Json.Linq.JToken,CryptoExchange.Net.Objects.CallResult{System.Object}@)">
            <summary>
            Needs to check if a received message was an answer to a subscription request (preferable by id) and set the callResult out to whatever the response is
            </summary>
            <param name="s">The socket connection</param>
            <param name="subscription"></param>
            <param name="request">The request that a response is awaited for</param>
            <param name="message">The message</param>
            <param name="callResult">The interpretation (null if message wasn't a response to the request)</param>
            <returns>True if the message was a response to the subscription request</returns>
        </member>
        <member name="M:CryptoExchange.Net.SocketClient.MessageMatchesHandler(Newtonsoft.Json.Linq.JToken,System.Object)">
            <summary>
            Needs to check if a received message matches a handler. Typically if an update message matches the request
            </summary>
            <param name="message">The received data</param>
            <param name="request">The subscription request</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.SocketClient.MessageMatchesHandler(Newtonsoft.Json.Linq.JToken,System.String)">
            <summary>
            Needs to check if a received message matches a handler. Typically if an received message matches a ping request or a other information pushed from the the server
            </summary>
            <param name="message">The received data</param>
            <param name="identifier">The string identifier of the handler</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.SocketClient.AuthenticateSocket(CryptoExchange.Net.Sockets.SocketConnection)">
            <summary>
            Needs to authenticate the socket so authenticated queries/subscriptions can be made on this socket connection
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.SocketClient.Unsubscribe(CryptoExchange.Net.Sockets.SocketConnection,CryptoExchange.Net.Sockets.SocketSubscription)">
            <summary>
            Needs to unsubscribe a subscription, typically by sending an unsubscribe request. If multiple subscriptions per socket is not allowed this can just return since the socket will be closed anyway
            </summary>
            <param name="connection">The connection on which to unsubscribe</param>
            <param name="s">The subscription to unsubscribe</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.SocketClient.ProcessTokenData(Newtonsoft.Json.Linq.JToken)">
            <summary>
            Optional handler to interpolate data before sending it to the handlers
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.SocketClient.AddHandler``1(System.Object,System.String,System.Boolean,CryptoExchange.Net.Sockets.SocketConnection,System.Action{``0})">
            <summary>
            Add a handler for a subscription
            </summary>
            <typeparam name="T">The type of data the subscription expects</typeparam>
            <param name="request">The request of the subscription</param>
            <param name="identifier">The identifier of the subscription (can be null if request param is used)</param>
            <param name="userSubscription">Whether or not this is a user subscription (counts towards the max amount of handlers on a socket)</param>
            <param name="connection">The socket connection the handler is on</param>
            <param name="dataHandler">The handler of the data received</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.SocketClient.AddGenericHandler(System.String,System.Action{CryptoExchange.Net.Sockets.SocketConnection,Newtonsoft.Json.Linq.JToken})">
            <summary>
            Adds a generic message handler. Used for example to reply to ping requests
            </summary>
            <param name="identifier">The name of the request handler. Needs to be unique</param>
            <param name="action">The action to execute when receiving a message for this handler (checked by <see cref="M:CryptoExchange.Net.SocketClient.MessageMatchesHandler(Newtonsoft.Json.Linq.JToken,System.String)"/>)</param>
        </member>
        <member name="M:CryptoExchange.Net.SocketClient.GetWebsocket(System.String,System.Boolean)">
            <summary>
            Gets a connection for a new subscription or query. Can be an existing if there are open position or a new one.
            </summary>
            <param name="address">The address the socket is for</param>
            <param name="authenticated">Whether the socket should be authenticated</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.SocketClient.ConnectSocket(CryptoExchange.Net.Sockets.SocketConnection)">
            <summary>
            Connect a socket
            </summary>
            <param name="socketConnection">The socket to connect</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.SocketClient.CreateSocket(System.String)">
            <summary>
            Create a socket for an address
            </summary>
            <param name="address">The address the socket should connect to</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.SocketClient.SendPeriodic(System.TimeSpan,System.Func{CryptoExchange.Net.Sockets.SocketConnection,System.Object})">
            <summary>
            Periodically sends an object to a socket
            </summary>
            <param name="interval">How often</param>
            <param name="objGetter">Method returning the object to send</param>
        </member>
        <member name="M:CryptoExchange.Net.SocketClient.Unsubscribe(CryptoExchange.Net.Sockets.UpdateSubscription)">
            <summary>
            Unsubscribe from a stream
            </summary>
            <param name="subscription">The subscription to unsubscribe</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.SocketClient.UnsubscribeAll">
            <summary>
            Unsubscribe all subscriptions
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.SocketClient.Dispose">
            <summary>
            Dispose the client
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Sockets.BaseSocket">
            <summary>
            Socket implementation
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Sockets.BaseSocket.socket">
            <summary>
            Socket
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Sockets.BaseSocket.log">
            <summary>
            Log
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Sockets.BaseSocket.errorHandlers">
            <summary>
            Error handlers
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Sockets.BaseSocket.openHandlers">
            <summary>
            Open handlers
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Sockets.BaseSocket.closeHandlers">
            <summary>
            Close handlers
            </summary>
        </member>
        <member name="F:CryptoExchange.Net.Sockets.BaseSocket.messageHandlers">
            <summary>
            Message handlers
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.BaseSocket.Id">
            <summary>
            Id
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.BaseSocket.Reconnecting">
            <summary>
            If is reconnecting
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.BaseSocket.Origin">
            <summary>
            Origin
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.BaseSocket.Url">
            <summary>
            Url
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.BaseSocket.IsClosed">
            <summary>
            Is closed
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.BaseSocket.IsOpen">
            <summary>
            Is open
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.BaseSocket.SSLProtocols">
            <summary>
            Protocols
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.BaseSocket.DataInterpreterBytes">
            <summary>
            Interpreter for bytes
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.BaseSocket.DataInterpreterString">
            <summary>
            Interpreter for strings
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.BaseSocket.LastActionTime">
            <summary>
            Last action time
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.BaseSocket.Timeout">
            <summary>
            Timeout
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.BaseSocket.SocketState">
            <summary>
            Socket state
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.BaseSocket.#ctor(CryptoExchange.Net.Logging.Log,System.String)">
            <summary>
            ctor
            </summary>
            <param name="log"></param>
            <param name="url"></param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.BaseSocket.#ctor(CryptoExchange.Net.Logging.Log,System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            ctor
            </summary>
            <param name="log"></param>
            <param name="url"></param>
            <param name="cookies"></param>
            <param name="headers"></param>
        </member>
        <member name="E:CryptoExchange.Net.Sockets.BaseSocket.OnClose">
            <summary>
            On close
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Sockets.BaseSocket.OnMessage">
            <summary>
            On message
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Sockets.BaseSocket.OnError">
            <summary>
            On error
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Sockets.BaseSocket.OnOpen">
            <summary>
            On open
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.BaseSocket.Handle(System.Collections.Generic.List{System.Action})">
            <summary>
            Handle
            </summary>
            <param name="handlers"></param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.BaseSocket.Handle``1(System.Collections.Generic.List{System.Action{``0}},``0)">
            <summary>
            Handle
            </summary>
            <typeparam name="T"></typeparam>
            <param name="handlers"></param>
            <param name="data"></param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.BaseSocket.CheckTimeout">
            <summary>
            Checks if timed out
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.BaseSocket.Close">
            <summary>
            Close socket
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.BaseSocket.Reset">
            <summary>
            Reset socket
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.BaseSocket.Send(System.String)">
            <summary>
            Send data
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.BaseSocket.Connect">
            <summary>
            Connect socket
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.BaseSocket.SetProxy(System.String,System.Int32)">
            <summary>
            Set a proxy
            </summary>
            <param name="host"></param>
            <param name="port"></param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.BaseSocket.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="T:CryptoExchange.Net.Sockets.SocketConnection">
            <summary>
            Socket connecting
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Sockets.SocketConnection.ConnectionLost">
            <summary>
            Connection lost event
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Sockets.SocketConnection.ConnectionRestored">
            <summary>
            Connecting restored event
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Sockets.SocketConnection.ActivityPaused">
            <summary>
            The connection is paused event
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Sockets.SocketConnection.ActivityUnpaused">
            <summary>
            The connection is unpaused event
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Sockets.SocketConnection.Closed">
            <summary>
            Connecting closed event
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.HandlerCount">
            <summary>
            The amount of handlers
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.Authenticated">
            <summary>
            If connection is authenticated
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.Connected">
            <summary>
            If connection is made
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.Socket">
            <summary>
            The socket
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.ShouldReconnect">
            <summary>
            If should reconnect upon closing
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.DisconnectTime">
            <summary>
            Time of disconnecting
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketConnection.PausedActivity">
            <summary>
            If activity is paused
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.#ctor(CryptoExchange.Net.SocketClient,CryptoExchange.Net.Interfaces.IWebsocket)">
            <summary>
            New socket connection
            </summary>
            <param name="client">The socket client</param>
            <param name="socket">The socket</param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.AddHandler(CryptoExchange.Net.Sockets.SocketSubscription)">
            <summary>
            Add handler
            </summary>
            <param name="handler"></param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.SendAndWait``1(``0,System.TimeSpan,System.Func{Newtonsoft.Json.Linq.JToken,System.Boolean})">
            <summary>
            Send data
            </summary>
            <typeparam name="T">The data type</typeparam>
            <param name="obj">The object to send</param>
            <param name="timeout">The timeout for response</param>
            <param name="handler">The response handler</param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.Send``1(``0,Newtonsoft.Json.NullValueHandling)">
            <summary>
            Send data to the websocket
            </summary>
            <typeparam name="T">The type of the object to send</typeparam>
            <param name="obj">The object to send</param>
            <param name="nullValueHandling">How null values should be serialized</param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.Send(System.String)">
            <summary>
            Send string data to the websocket
            </summary>
            <param name="data">The data to send</param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.SocketOnClose">
            <summary>
            Handler for a socket closing. Reconnects the socket if needed, or removes it from the active socket list if not
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.Close">
            <summary>
            Close the connection
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketConnection.Close(CryptoExchange.Net.Sockets.SocketSubscription)">
            <summary>
            Close the subscription
            </summary>
            <param name="subscription">Subscription to close</param>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Sockets.SocketSubscription">
            <summary>
            Socket subscription
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Sockets.SocketSubscription.Exception">
            <summary>
            Exception event
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketSubscription.MessageHandler">
            <summary>
            Message handlers for this subscription. Should return true if the message is handled and should not be distributed to the other handlers
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketSubscription.Request">
            <summary>
            Request object
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketSubscription.Identifier">
            <summary>
            Subscription identifier
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketSubscription.UserSubscription">
            <summary>
            Is user subscription or generic
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.SocketSubscription.Confirmed">
            <summary>
            If the subscription has been confirmed
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketSubscription.CreateForRequest(System.Object,System.Boolean,System.Action{CryptoExchange.Net.Sockets.SocketConnection,Newtonsoft.Json.Linq.JToken})">
            <summary>
            Create SocketSubscription for a request
            </summary>
            <param name="request"></param>
            <param name="userSubscription"></param>
            <param name="dataHandler"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketSubscription.CreateForIdentifier(System.String,System.Boolean,System.Action{CryptoExchange.Net.Sockets.SocketConnection,Newtonsoft.Json.Linq.JToken})">
            <summary>
            Create SocketSubscription for an identifier
            </summary>
            <param name="identifier"></param>
            <param name="userSubscription"></param>
            <param name="dataHandler"></param>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.SocketSubscription.InvokeExceptionHandler(System.Exception)">
            <summary>
            Invoke the exception event
            </summary>
            <param name="e"></param>
        </member>
        <member name="T:CryptoExchange.Net.Sockets.UpdateSubscription">
            <summary>
            Subscription
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Sockets.UpdateSubscription.ConnectionLost">
            <summary>
            Event when the connection is lost. The socket will automatically reconnect when possible.
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Sockets.UpdateSubscription.ConnectionRestored">
            <summary>
            Event when the connection is restored. Timespan parameter indicates the time the socket has been offline for before reconnecting
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Sockets.UpdateSubscription.ActivityPaused">
            <summary>
            Event when the connection to the server is paused. No operations can be performed while paused
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Sockets.UpdateSubscription.ActivityUnpaused">
            <summary>
            Event when the connection to the server is unpaused
            </summary>
        </member>
        <member name="E:CryptoExchange.Net.Sockets.UpdateSubscription.Exception">
            <summary>
            Event when an exception happened
            </summary>
        </member>
        <member name="P:CryptoExchange.Net.Sockets.UpdateSubscription.Id">
            <summary>
            The id of the socket
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.UpdateSubscription.#ctor(CryptoExchange.Net.Sockets.SocketConnection,CryptoExchange.Net.Sockets.SocketSubscription)">
            <summary>
            ctor
            </summary>
            <param name="connection"></param>
            <param name="subscription"></param>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.UpdateSubscription.Close">
            <summary>
            Close the subscription
            </summary>
            <returns></returns>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.UpdateSubscription.Reconnect">
            <summary>
            Close the socket to cause a reconnect
            </summary>
            <returns></returns>
        </member>
        <member name="T:CryptoExchange.Net.Sockets.WebsocketFactory">
            <summary>
            Factory implementation
            </summary>
        </member>
        <member name="M:CryptoExchange.Net.Sockets.WebsocketFactory.CreateWebsocket(CryptoExchange.Net.Logging.Log,System.String)">
            <inheritdoc />
        </member>
        <member name="M:CryptoExchange.Net.Sockets.WebsocketFactory.CreateWebsocket(CryptoExchange.Net.Logging.Log,System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String})">
            <inheritdoc />
        </member>
    </members>
</doc>
